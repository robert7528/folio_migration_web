{% extends "base.html" %}

{% block title %}Edit: {{ filename }}{% endblock %}

{% block content %}
<div class="flex-between mb-2">
    <h1>Edit Configuration: {{ filename }}</h1>
    <a href="{{ root_path }}/clients/{{ client_code }}" class="btn btn-secondary">Back to Project</a>
</div>

<div class="card">
    <div class="editor-toolbar">
        <span id="file-type-badge" class="badge" style="margin-right: 1rem;"></span>
        <button id="btn-format" class="btn btn-secondary" onclick="formatJson()">Format JSON</button>
        <button id="btn-validate" class="btn btn-secondary" onclick="validateConfig()">Validate</button>
        <button class="btn btn-primary" onclick="saveConfig()">Save</button>
    </div>

    <div class="editor-container">
        <textarea id="json-editor" spellcheck="false"></textarea>
    </div>
</div>

<div id="validation-results" style="display: none;"></div>
{% endblock %}

{% block scripts %}
<script>
const clientCode = '{{ client_code }}';
const filename = '{{ filename }}';
let originalContent = null;
let fileType = 'json';

document.addEventListener('DOMContentLoaded', async () => {
    await loadConfig();
});

async function loadConfig() {
    try {
        const response = await fetch(`${ROOT_PATH}/api/clients/${clientCode}/config/${filename}`);
        if (!response.ok) {
            const error = await response.json();
            let errorMsg = 'Failed to load configuration';
            if (error.detail) {
                errorMsg = typeof error.detail === 'string' ? error.detail : JSON.stringify(error.detail);
            }
            throw new Error(errorMsg);
        }

        const data = await response.json();
        originalContent = data.content;
        fileType = data.file_type || 'json';

        const editor = document.getElementById('json-editor');
        const badge = document.getElementById('file-type-badge');
        const btnFormat = document.getElementById('btn-format');
        const btnValidate = document.getElementById('btn-validate');

        if (fileType === 'json') {
            editor.value = JSON.stringify(data.content, null, 4);
            badge.textContent = 'JSON';
            badge.className = 'badge badge-info';
            btnFormat.style.display = 'inline-block';
            // Only show Validate button for migration_config.json (has schema validation)
            const isConfigFile = filename === 'migration_config.json';
            btnValidate.style.display = isConfigFile ? 'inline-block' : 'none';
        } else {
            // Text file (TSV, CSV, TXT)
            editor.value = data.content;
            badge.textContent = filename.split('.').pop().toUpperCase();
            badge.className = 'badge badge-secondary';
            btnFormat.style.display = 'none';
            btnValidate.style.display = 'none';
        }

    } catch (error) {
        showResult(false, error.message || String(error));
    }
}

function formatJson() {
    const editor = document.getElementById('json-editor');
    try {
        const parsed = JSON.parse(editor.value);
        editor.value = JSON.stringify(parsed, null, 4);
        showResult(true, 'JSON formatted successfully');
    } catch (error) {
        showResult(false, `Invalid JSON: ${error.message}`);
    }
}

async function validateConfig() {
    const editor = document.getElementById('json-editor');

    try {
        const content = JSON.parse(editor.value);

        // Check if this looks like a migration config
        if (!content.libraryInformation && !content.migrationTasks) {
            showResult(false, 'This file is not a migration configuration. Validation only works for migration_config.json.');
            return;
        }

        const response = await fetch(`${ROOT_PATH}/api/clients/${clientCode}/config/validate`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(content)
        });

        const result = await response.json();

        if (result.valid) {
            showResult(true, 'Configuration is valid');
        } else if (result.errors && Array.isArray(result.errors)) {
            const errors = result.errors.map(e => `${e.loc ? e.loc.join('.') : 'unknown'}: ${e.msg || e.message || 'error'}`).join('\n');
            showResult(false, `Validation errors:\n${errors}`);
        } else {
            showResult(false, 'Validation failed: ' + JSON.stringify(result));
        }
    } catch (error) {
        showResult(false, `Invalid JSON: ${error.message}`);
    }
}

async function saveConfig() {
    const editor = document.getElementById('json-editor');

    try {
        let body;
        let content;

        if (fileType === 'json') {
            content = JSON.parse(editor.value);
            body = JSON.stringify(content);
        } else {
            // Text file
            content = editor.value;
            body = JSON.stringify({ content: content });
        }

        const response = await fetch(`${ROOT_PATH}/api/clients/${clientCode}/config/${filename}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: body
        });

        if (!response.ok) {
            const error = await response.json();
            if (error.detail && typeof error.detail === 'object' && error.detail.errors) {
                const errors = error.detail.errors.map(e => `${e.loc.join('.')}: ${e.msg}`).join('\n');
                throw new Error(`Validation failed:\n${errors}`);
            }
            let errorMsg = typeof error.detail === 'string' ? error.detail : JSON.stringify(error.detail) || 'Failed to save';
            throw new Error(errorMsg);
        }

        showResult(true, 'Configuration saved successfully');
        originalContent = content;

    } catch (error) {
        showResult(false, error.message || String(error));
    }
}

function showResult(success, message) {
    const el = document.getElementById('validation-results');
    el.className = `validation-results ${success ? 'valid' : 'invalid'}`;
    el.style.display = 'block';
    el.style.whiteSpace = 'pre-wrap';
    el.textContent = message;
}

// Warn before leaving with unsaved changes
window.addEventListener('beforeunload', (e) => {
    const editor = document.getElementById('json-editor');
    try {
        let current;
        if (fileType === 'json') {
            current = JSON.parse(editor.value);
            if (JSON.stringify(current) !== JSON.stringify(originalContent)) {
                e.preventDefault();
                e.returnValue = '';
            }
        } else {
            current = editor.value;
            if (current !== originalContent) {
                e.preventDefault();
                e.returnValue = '';
            }
        }
    } catch {
        // Invalid JSON, warn anyway
        e.preventDefault();
        e.returnValue = '';
    }
});

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
    if (e.ctrlKey || e.metaKey) {
        switch (e.key) {
            case 's':
                e.preventDefault();
                saveConfig();
                break;
            case 'f':
                if (e.shiftKey) {
                    e.preventDefault();
                    formatJson();
                }
                break;
        }
    }
});
</script>
{% endblock %}
